name: Run Tests with Coverage

# This workflow triggers on pushes and pull requests to main branch
# You can customize these triggers based on your needs
on:
  workflow_dispatch:


jobs:
  test:
    # Use the latest Ubuntu runner - you can specify specific versions if needed
    runs-on: ubuntu-latest

    # Define a strategy matrix if you want to test against multiple Python versions
    strategy:
      matrix:
        python-version: [3.9, "3.10", 3.11, 3.12, 3.13]  # Add more versions as needed

    steps:
    # Step 1: Check out the repository code
    - name: Checkout code
      uses: actions/checkout@v4

    # Step 2: Install uv (ultra-fast Python package installer)
    - name: Install uv
      uses: astral-sh/setup-uv@v3
      with:
        # Enable uv cache for faster subsequent runs
        enable-cache: true
        # Optionally specify uv version - leave blank for latest
        # version: "0.4.0"

    # Step 3: Set up Python environment using uv
    - name: Set up Python ${{ matrix.python-version }}
      run: |
        # uv can install and manage Python versions directly
        uv python install ${{ matrix.python-version }}
        uv python pin ${{ matrix.python-version }}

    # Step 4: Install dependencies using uv
    - name: Install dependencies
      run: |
        # Create virtual environment using uv (much faster than venv)
        uv venv
        # Activate virtual environment
        source .venv/bin/activate

        # Install pytest and coverage tools using uv
        uv add --dev pytest pytest-cov pytest-html pytest-json-report

        # Install project dependencies based on what's available
        # uv automatically detects and installs from pyproject.toml, requirements.txt, etc.
        if [ -f pyproject.toml ]; then
          # Install project in development mode with all dependencies
          uv sync --dev
        elif [ -f requirements.txt ]; then
          # Install from requirements.txt
          uv pip install -r requirements.txt
          # Install dev requirements if they exist
          if [ -f requirements-dev.txt ]; then
            uv pip install -r requirements-dev.txt
          fi
          # Install current package in development mode if setup.py exists
          if [ -f setup.py ]; then
            uv pip install -e .
          fi
        else
          # Fallback: just install the testing dependencies
          echo "No dependency files found, only test dependencies installed"
        fi

    # Step 5: Run tests with coverage using uv
    - name: Run pytest with coverage
      run: |
        # Activate the virtual environment created by uv
        source .venv/bin/activate

        # Create reports directory to organize output files
        mkdir -p reports

        # Run pytest with multiple output formats
        # The beauty of uv is that all dependencies are already properly resolved
        pytest ./src/tests/ \
          --cov=src \
          --cov=your_package_name \
          --cov-report=html:reports/htmlcov \
          --cov-report=xml:reports/coverage.xml \
          --cov-report=term-missing \
          --html=reports/pytest_report.html \
          --self-contained-html \
          --json-report --json-report-file=reports/pytest_report.json \
          --junitxml=reports/junit.xml \
          -v
      # Continue on error so we can still upload partial results
      continue-on-error: true

    # Step 6: Upload test results and coverage reports as artifacts
    - name: Upload test results and coverage reports
      uses: actions/upload-artifact@v4
      if: always()  # Upload even if tests failed
      with:
        name: test-results-python-${{ matrix.python-version }}
        path: |
          reports/
          .coverage
        retention-days: 30  # Keep artifacts for 30 days

    # Step 7: Upload coverage to external service (optional)
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      if: always()
      with:
        file: reports/coverage.xml
