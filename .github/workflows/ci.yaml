name: CI/CD Pipeline
'on':
  push:
    branches:
      - main


# Prevent duplicate runs for PR pushes
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Run Tests and Coverage
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version:
          - '3.12'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: 'Set up Python ${{ matrix.python-version }}'
        uses: actions/setup-python@v4
        with:
          python-version: '${{ matrix.python-version }}'
      - name: Install uv
        uses: astral-sh/setup-uv@v2
        with:
          version: latest
      - name: Create virtual environment
        run: uv venv
      - name: Install dependencies
        run: |
          uv pip install -e .
          uv pip install pytest pytest-cov pytest-xdist
      - name: Run tests with pytest
        run: |
          source .venv/bin/activate
          pytest --cov=attercop --cov-report=xml --cov-report=term-missing -v
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
  security:
    name: Security Scans With Bandit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install uv
        uses: astral-sh/setup-uv@v2
        with:
          version: latest
      - name: Create virtual environment
        run: uv venv
      - name: Install dependencies
        run: |
          uv pip install -e .
          uv pip install bandit safety pip-audit
      - name: Run Bandit security scan
        run: |
          source .venv/bin/activate
          bandit -r attercop/ -f json -o bandit-report.json || true
          bandit -r attercop/ -f txt
        continue-on-error: true
      - name: Run Safety check
        run: |
          source .venv/bin/activate
          safety check --json --output safety-report.json || true
          safety check
        continue-on-error: true
      - name: Run pip-audit
        run: |
          source .venv/bin/activate
          pip-audit --format=json --output=pip-audit-report.json || true
          pip-audit
        continue-on-error: true
      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
            pip-audit-report.json
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python
          queries: 'security-extended,security-and-quality'
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  scan:
    name: Check GitLeaks for Secrets
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  semantic_release:
    name: Get Next Version
    needs: [test, security, codeql, scan]
    runs-on: ubuntu-latest

    outputs:
      next-version: ${{ steps.version.outputs.next-version }}
      current-version: ${{ steps.version.outputs.current-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for semantic versioning

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install GitPython

      - name: Calculate next version
        id: version
        run: |
          python << 'EOF'
          import os
          import re
          import subprocess
          from git import Repo

          def get_current_version():
              """Get the current version from git tags"""
              try:
                  result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'],
                                        capture_output=True, text=True, check=True)
                  return result.stdout.strip()
              except subprocess.CalledProcessError:
                  return "v0.0.0"

          def parse_version(version_str):
              """Parse version string into components"""
              # Remove 'v' prefix if present
              clean_version = version_str.lstrip('v')
              parts = clean_version.split('.')
              return {
                  'major': int(parts[0]) if len(parts) > 0 else 0,
                  'minor': int(parts[1]) if len(parts) > 1 else 0,
                  'patch': int(parts[2]) if len(parts) > 2 else 0
              }

          def analyze_commits_since_tag(repo, last_tag):
              """Analyze commits since last tag to determine version bump"""
              try:
                  if last_tag == "v0.0.0":
                      # No previous tags, get all commits
                      commits = list(repo.iter_commits())
                  else:
                      # Get commits since last tag
                      commits = list(repo.iter_commits(f'{last_tag}..HEAD'))
              except:
                  commits = list(repo.iter_commits())

              has_breaking = False
              has_feature = False
              has_fix = False

              for commit in commits:
                  message = commit.message.lower().strip()

                  # Check for breaking changes
                  if ('breaking change' in message or
                      message.startswith('feat!:') or
                      message.startswith('fix!:') or
                      '!' in message.split(':')[0] if ':' in message else False):
                      has_breaking = True

                  # Check for features
                  elif message.startswith('feat:') or message.startswith('feature:'):
                      has_feature = True

                  # Check for fixes
                  elif message.startswith('fix:') or message.startswith('bugfix:'):
                      has_fix = True

              return has_breaking, has_feature, has_fix

          def calculate_next_version(current_version, has_breaking, has_feature, has_fix):
              """Calculate next version based on changes"""
              version = parse_version(current_version)

              if has_breaking:
                  version['major'] += 1
                  version['minor'] = 0
                  version['patch'] = 0
              elif has_feature:
                  version['minor'] += 1
                  version['patch'] = 0
              elif has_fix:
                  version['patch'] += 1
              else:
                  # No semantic changes found
                  return current_version

              # Maintain 'v' prefix if current version has it
              prefix = 'v' if current_version.startswith('v') else ''
              return f"{prefix}{version['major']}.{version['minor']}.{version['patch']}"

          # Main logic
          repo = Repo('.')
          current_version = get_current_version()

          print(f"Current version: {current_version}")

          has_breaking, has_feature, has_fix = analyze_commits_since_tag(repo, current_version)

          print(f"Analysis results:")
          print(f"  Breaking changes: {has_breaking}")
          print(f"  New features: {has_feature}")
          print(f"  Bug fixes: {has_fix}")

          next_version = calculate_next_version(current_version, has_breaking, has_feature, has_fix)

          print(f"Next version: {next_version}")

          # Set GitHub outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"current-version={current_version}\n")
              f.write(f"next-version={next_version}\n")

          # Set environment variables for next steps
          with open(os.environ['GITHUB_ENV'], 'a') as f:
              f.write(f"CURRENT_VERSION={current_version}\n")
              f.write(f"NEXT_VERSION={next_version}\n")
          EOF

      - name: Print version info
        run: |
          echo "Current version: ${{ steps.version.outputs.current-version }}"
          echo "Next version: ${{ steps.version.outputs.next-version }}"
          if [ "${{ steps.version.outputs.current-version }}" != "${{ steps.version.outputs.next-version }}" ]; then
            echo "Version will be bumped!"
          else
            echo "No version bump needed"
          fi
